<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üîÆ AstroOne Live ‚Äî Talk with Sumit Aggarwal</title>
<style>
  :root{--accent:#6a11cb;--accent-dark:#4a0fa8}
  body{margin:0;height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#6a11cb,#2575fc);font-family:Inter,system-ui,Arial;color:#222}
  .card{width:520px;background:#fff;border-radius:14px;padding:22px;box-shadow:0 18px 45px rgba(0,0,0,0.15)}
  h1{margin:0 0 10px;text-align:center;font-size:20px}
  label{font-size:13px;color:#444;margin-top:8px;display:block}
  input,select,button{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #ddd;font-size:14px;box-sizing:border-box}
  .row{display:flex;gap:10px}
  #connect{background:var(--accent);color:#fff;border:none;cursor:pointer}
  #connect:hover{background:var(--accent-dark)}
  #disconnect{background:#e74c3c;color:#fff;border:none;cursor:pointer;display:none}
  #status{margin-top:12px;color:#333;min-height:20px;text-align:center}
  .muted{font-size:12px;color:#888;text-align:center;margin-top:8px}
  .small{font-size:12px;color:#666;margin-top:6px}
</style>
</head>
<body>
  <div class="card">
    <h1>üîÆ AstroOne Live ‚Äî Talk with Sumit Aggarwal</h1>

    <label>‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ</label>
    <input id="name" placeholder="‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ">

    <div class="row">
      <div style="flex:1">
        <label>DOB</label>
        <input id="dob" type="date">
      </div>
      <div style="flex:1">
        <label>Time</label>
        <input id="tob" type="time">
      </div>
    </div>

    <label>Place of Birth (POB)</label>
    <input id="pob" placeholder="‡§∂‡§π‡§∞, ‡§∞‡§æ‡§ú‡•ç‡§Ø ‡§Ø‡§æ ‡§¶‡•á‡§∂">

    <div class="row">
      <div style="flex:1">
        <label>Gender</label>
        <select id="gender"><option value="">Select</option><option value="male">Male</option><option value="female">Female</option></select>
      </div>
      <div style="flex:1">
        <label>Voice</label>
        <select id="voice">
          <option value="verse">Verse</option>
          <option value="alloy">Alloy</option>
          <option value="ash">Ash</option>
          <option value="ballad">Ballad</option>
          <option value="coral">Coral</option>
          <option value="echo">Echo</option>
          <option value="sage">Sage</option>
          <option value="shimmer">Shimmer</option>
          <option value="marin">Marin</option>
          <option value="cedar">Cedar</option>
        </select>
      </div>
    </div>

    <div style="margin-top:12px;display:flex;gap:10px">
      <button id="connect">‚ñ∂Ô∏è Start Live Call</button>
      <button id="disconnect">‚èπ Stop</button>
    </div>

    <div id="status">Fill details and press Start.</div>
    <div class="muted">Note: Allow microphone permissions in your browser.</div>
    <div class="small">Tip: If audio is still faint, test headphones and browser tab audio output volume.</div>
  </div>

<script>
/*
  client/index_ws.html - Main script part 1/2
  We'll build the AudioWorklet module as a JS string and load via blob,
  then create AudioWorkletNode to stream mic Float32 chunks to main thread.
*/

// DOM refs
const connectBtn = document.getElementById("connect");
const disconnectBtn = document.getElementById("disconnect");
const statusEl = document.getElementById("status");

// state
let ws = null;
let audioCtx = null;
let micStream = null;
let workletNode = null;
let commitTimer = null;

// helper: set status
function setStatus(text) { statusEl.innerText = text; console.log(text); }

// Convert Float32Array -> 16-bit PCM LE -> base64
function floatToBase64(float32Array) {
  const len = float32Array.length;
  const buffer = new ArrayBuffer(len * 2);
  const view = new DataView(buffer);
  for (let i = 0; i < len; i++) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const CHUNK = 0x8000;
  for (let i = 0; i < bytes.length; i += CHUNK) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK));
  }
  return btoa(binary);
}

// Decode Ogg/Opus base64 audio from OpenAI Realtime and play cleanly
async function playPCMBase64(b64) {
  try {
    // Convert base64 ‚Üí binary
    const binary = atob(b64);
    const len = binary.length;
    const buffer = new ArrayBuffer(len);
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);

    if (!audioCtx)
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // This handles Ogg/Opus, MP3, WAV ‚Äî any encoded audio format
    const decoded = await audioCtx.decodeAudioData(buffer);
    const src = audioCtx.createBufferSource();
    src.buffer = decoded;
    src.connect(audioCtx.destination);
    src.start(0);
  } catch (err) {
    console.warn("Audio decode/play error:", err);
  }
}
// Build AudioWorklet processor code as a string.
// It will post Float32Array chunks to main thread via port.postMessage.
const workletCode = `class MicProcessor extends AudioWorkletProcessor {
  process (inputs) {
    try {
      const input = inputs[0];
      if (input && input[0]) {
        // copy to transferable Float32Array for main thread
        const channel = input[0];
        const buf = new Float32Array(channel.length);
        for (let i = 0; i < channel.length; i++) buf[i] = channel[i];
        // post message (structured clone works)
        this.port.postMessage(buf, [buf.buffer]);
      }
    } catch (e) {
      // swallow errors
    }
    return true;
  }
}
registerProcessor('mic-processor', MicProcessor);`;

// utility to load worklet from string
async function addWorkletFromString(ctx, codeStr) {
  const blob = new Blob([codeStr], { type: "application/javascript" });
  const blobUrl = URL.createObjectURL(blob);
  try {
    await ctx.audioWorklet.addModule(blobUrl);
  } finally {
    URL.revokeObjectURL(blobUrl);
  }
}

/* ---------- Start call: open WS, create AudioWorklet, stream mic ---------- */
async function startCall() {
  const name = document.getElementById("name").value.trim();
  const dob = document.getElementById("dob").value;
  const tob = document.getElementById("tob").value;
  const pob = document.getElementById("pob").value.trim();
  const gender = document.getElementById("gender").value;
  const voice = document.getElementById("voice").value || "verse";

  if (!name || !dob || !tob || !pob || !gender) {
    setStatus("‚ö†Ô∏è ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§≠‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§≠‡§∞‡•á‡§Ç‡•§");
    return;
  }

  // open websocket to our server
  const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
  ws = new WebSocket(wsUrl);
  setStatus("üõ∞ Connecting...");

  ws.onopen = async () => {
    setStatus("üîÆ Connected. Sending init...");
    ws.send(JSON.stringify({ type: "init", name, dob, tob, pob, gender, voice }));

    // slight delay to let server connect to OpenAI WS
    await new Promise(r => setTimeout(r, 700));

    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      setStatus("üîá Microphone permission denied.");
      console.error(e);
      return;
    }

    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();

    // Add worklet module from our string
    try {
      await addWorkletFromString(audioCtx, workletCode);
    } catch (e) {
      console.error("Failed to add worklet:", e);
      setStatus("‚ö†Ô∏è AudioWorklet not available in this browser.");
      return;
    }

    const micSource = audioCtx.createMediaStreamSource(micStream);
    workletNode = new AudioWorkletNode(audioCtx, "mic-processor", { numberOfInputs: 1, numberOfOutputs: 0 });
    // receive Float32Array chunks from worklet
    workletNode.port.onmessage = (ev) => {
      try {
        const float32 = ev.data; // Float32Array (transferred)
        if (!float32 || !float32.length) return;
        // convert to base64 PCM16LE and send
        const b64 = floatToBase64(float32);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "media", data: b64 }));
        }
      } catch (err) {
        console.warn("worklet->main error", err);
      }
    };

    micSource.connect(workletNode);

    // commits: initial and periodic
    setTimeout(() => { if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "media_commit" })); }, 1000);
    commitTimer = setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "media_commit" }));
      }
    }, 2500);

    connectBtn.style.display = "none";
    disconnectBtn.style.display = "inline-block";
    setStatus("üéô Live ‚Äî ‡§¨‡•ã‡§≤‡§ø‡§è...");
  };

  ws.onmessage = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      if (msg?.type === "output_audio_binary" && msg?.data) {
        const sr = msg.sampleRate || 24000;
        playPCMBase64(msg.data, sr);
      } else {
        // other informational messages (init_ok, text chunks, etc.)
        console.debug("server:", msg);
      }
    } catch (e) {
      console.warn("ws message parse error", e);
    }
  };

  ws.onerror = (err) => {
    console.error("WebSocket error:", err);
    setStatus("‚ùå Connection error.");
    stopCall();
  };

  ws.onclose = () => {
    setStatus("üì¥ Call ended.");
    stopCall();
  };
}

function stopCall() {
  try { if (commitTimer) { clearInterval(commitTimer); commitTimer = null; } } catch {}
  try { if (workletNode) { workletNode.port.onmessage = null; workletNode.disconnect(); workletNode = null; } } catch {}
  try { if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; } } catch {}
  try { if (ws) { if (ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "stop" })); ws.close(); } ws = null; } catch {}
  connectBtn.style.display = "inline-block";
  disconnectBtn.style.display = "none";
}

// attach handlers
connectBtn.addEventListener("click", startCall);
disconnectBtn.addEventListener("click", stopCall);
</script>
</body>
</html>
