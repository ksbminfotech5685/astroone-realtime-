<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üîÆ AstroOne Live ‚Äî Sumit Agarwal</title>
<style>
  :root{--accent:#6a11cb;--accent-dark:#5a0fba}
  body{margin:0;height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);font-family:Inter,system-ui,Arial;color:#222}
  .card{width:460px;background:#fff;border-radius:14px;padding:22px;box-shadow:0 14px 40px rgba(0,0,0,0.18);text-align:left}
  h1{margin:0 0 8px;font-size:20px}
  label{font-size:13px;color:#444;margin-top:8px;display:block}
  input,select,button{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #ddd;font-size:14px;box-sizing:border-box}
  .row{display:flex;gap:10px}
  .small{width:50%}
  #connect{background:var(--accent);color:#fff;border:none;cursor:pointer}
  #connect:hover{background:var(--accent-dark)}
  #disconnect{background:#e74c3c;color:#fff;border:none;cursor:pointer;display:none}
  #status{margin-top:12px;color:#333;min-height:20px}
  .center{display:flex;gap:8px;align-items:center}
  .muted{color:#888;font-size:12px;margin-top:8px}
</style>
</head>
<body>
  <div class="card">
    <h1>üîÆ AstroOne Live ‚Äî Talk with Sumit Agarwal</h1>

    <label>‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ</label>
    <input id="name" placeholder="‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ">

    <div class="row">
      <div style="flex:1">
        <label>DOB</label>
        <input id="dob" type="date">
      </div>
      <div style="flex:1">
        <label>Time</label>
        <input id="tob" type="time">
      </div>
    </div>

    <label>Place of Birth (POB)</label>
    <input id="pob" placeholder="‡§∂‡§π‡§∞, ‡§∞‡§æ‡§ú‡•ç‡§Ø ‡§Ø‡§æ ‡§¶‡•á‡§∂">

    <div class="row">
      <div style="flex:1">
        <label>Gender</label>
        <select id="gender"><option value="">Select</option><option value="male">Male</option><option value="female">Female</option><option value="other">Other</option></select>
      </div>
      <div style="flex:1">
        <label>Voice</label>
        <select id="voice">
          <option value="verse">Verse</option>
          <option value="alloy">Alloy</option>
          <option value="ash">Ash</option>
          <option value="ballad">Ballad</option>
          <option value="coral">Coral</option>
          <option value="echo">Echo</option>
          <option value="sage">Sage</option>
          <option value="shimmer">Shimmer</option>
          <option value="marin">Marin</option>
          <option value="cedar">Cedar</option>
        </select>
      </div>
    </div>

    <div style="margin-top:12px" class="center">
      <button id="connect">‚ñ∂Ô∏è Start Live Call</button>
      <button id="disconnect">‚èπ Stop</button>
    </div>

    <div id="status">Fill details and press Start.</div>
    <div class="muted">Note: allow microphone permissions in your browser.</div>

    <audio id="audioPlayer" autoplay playsinline></audio>
  </div>

<script>
/*
client/index_ws.html
- Connects to server WS at /ws (same origin)
- Sends init (kundli data)
- Streams mic audio as base64 PCM16 via {type:'media', data: base64}
- Periodically sends {type:'media_commit'} to trigger OpenAI response
- Plays returned binary audio frames (base64) from server (type 'output_audio_binary')
*/

const connectBtn = document.getElementById("connect");
const disconnectBtn = document.getElementById("disconnect");
const statusEl = document.getElementById("status");
const audioPlayer = document.getElementById("audioPlayer");

let ws = null;
let audioCtx = null;
let sourceNode = null;
let processor = null;
let mediaStream = null;
let commitInterval = null;

function setStatus(t){ statusEl.innerText = t; console.log(t); }

// Convert Float32 PCM -> 16-bit PCM LE -> base64
function floatToBase64(float32Array){
  const len = float32Array.length;
  const buffer = new ArrayBuffer(len * 2);
  const view = new DataView(buffer);
  for (let i = 0; i < len; i++){
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  // binary -> base64
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const CHUNK = 0x8000;
  for (let i = 0; i < bytes.length; i += CHUNK) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK));
  }
  return btoa(binary);
}

// Play raw 16-bit PCM base64 frames
function playBase64Audio(b64) {
  try {
    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    const len = bytes.length / 2;
    const float32 = new Float32Array(len);
    for (let i = 0; i < len; i++) {
      const val = (bytes[i * 2 + 1] << 8) | bytes[i * 2];
      const s = val > 32767 ? val - 65536 : val;
      float32[i] = s / 32768;
    }
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const buffer = audioCtx.createBuffer(1, len, 44100);
    buffer.getChannelData(0).set(float32);
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(audioCtx.destination);
    src.start();
  } catch (e) {
    console.warn("PCM play error", e);
  }
}

// Start the call
async function startCall(){
  const name = document.getElementById("name").value.trim();
  const dob = document.getElementById("dob").value;
  const tob = document.getElementById("tob").value;
  const pob = document.getElementById("pob").value.trim();
  const gender = document.getElementById("gender").value;
  const voice = document.getElementById("voice").value || "verse";

  if (!name || !dob || !tob || !pob || !gender) {
    setStatus("‚ö†Ô∏è ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§≠‡•Ä ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§≠‡§∞‡•á‡§Ç‡•§");
    return;
  }

  // Open WebSocket (same origin, path /ws)
  const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
  ws = new WebSocket(wsUrl);
  setStatus("üõ∞ Connecting to server...");

  ws.onopen = async () => {
    setStatus("üîÆ Connected. Sending init...");
    // Send init => server will create/prepare OpenAI session (includes kundli instructions)
    ws.send(JSON.stringify({ type: "init", name, dob, tob, pob, gender, voice }));

    // small wait to allow server to establish/prepare OpenAI WS
    await new Promise(r => setTimeout(r, 900));

    // get mic
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      setStatus("üîá Microphone permission denied.");
      console.error(e);
      return;
    }

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sourceNode = audioCtx.createMediaStreamSource(mediaStream);
    processor = audioCtx.createScriptProcessor(4096, 1, 1);
    sourceNode.connect(processor);
    processor.connect(audioCtx.destination);

    processor.onaudioprocess = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const float32 = e.inputBuffer.getChannelData(0);
      const b64 = floatToBase64(float32);
      ws.send(JSON.stringify({ type: "media", data: b64 }));
    };

    // immediate commit after 1s, then periodic commits every 2.5s
    setTimeout(() => { if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "media_commit" })); }, 1000);
    commitInterval = setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "media_commit" }));
    }, 2500);

    connectBtn.style.display = "none";
    disconnectBtn.style.display = "inline-block";
    setStatus("üéô Live ‚Äî ‡§¨‡•ã‡§≤‡§ø‡§è...");
  };

  ws.onmessage = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      // server forwards binary frames as output_audio_binary with base64 payload
      if (msg?.type === "output_audio_binary" && msg?.data) {
        playBase64Audio(msg.data);
      } else if (msg?.type === "output_audio_buffer.append" && msg?.audio) {
        // some event shapes include .audio
        playBase64Audio(msg.audio);
      } else {
        // debug / text tokens or other events
        console.debug("svr>", msg);
      }
    } catch (e) {
      console.warn("ws message parse error", e);
    }
  };

  ws.onerror = (err) => {
    console.error("WS error", err);
    setStatus("‚ùå Connection error.");
    stopCall();
  };

  ws.onclose = () => {
    setStatus("üì¥ Call ended.");
    stopCall();
  };
}

function stopCall(){
  if (commitInterval) { clearInterval(commitInterval); commitInterval = null; }
  try { if (processor) { processor.disconnect(); processor = null; } } catch {}
  try { if (sourceNode) { sourceNode.disconnect(); sourceNode = null; } } catch {}
  try { if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; } } catch {}
  try { if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: "stop" })); } catch {}
  try { if (ws) ws.close(); } catch {}
  ws = null;
  connectBtn.style.display = "inline-block";
  disconnectBtn.style.display = "none";
}

// Attach
connectBtn.addEventListener("click", startCall);
disconnectBtn.addEventListener("click", stopCall);
</script>
</body>
</html>
